<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Complex Gadgets/Merkle Tree - docs</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Gadgets</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gadgets/gadgets.html"><strong aria-hidden="true">2.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../gadgets/complex_gadgets.html" class="active"><strong aria-hidden="true">2.2.</strong> Complex Gadgets/Merkle Tree</a></li></ol></li><li class="chapter-item expanded "><a href="../crypto_primitives.html"><strong aria-hidden="true">3.</strong> Crypto Primitives</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">docs</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="complex-gadgetsmerkle-tree-example"><a class="header" href="#complex-gadgetsmerkle-tree-example">Complex Gadgets/Merkle Tree Example</a></h1>
<p>So far we've been discussing the circuit equivalent of primitive types that all programming languages support. Eventually, the need for custom types (i.e. structs) arises.</p>
<p>For this, let's go through an example of how this would work. The following will be taken from the <code>MerkleTree</code> example <a href="https://github.com/Entropy1729/simpleworks/tree/main/examples/merkle-tree">here</a>. The goal is to create a circuit that, given a merkle root, leaf and a path to the leaf, decides whether the leaf belongs to the tree or not.</p>
<p>So we don't reinvent the wheel, we are going to use a fixed height merkle tree implementation provided by the <code>crypto-primitives</code> package in arkworks. This gives us a struct </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MerkleTree&lt;P: Config&gt;
<span class="boring">}
</span></code></pre></pre>
<p>where the <code>Config</code> is just a generic type with the hash functions used for the tree (yes, it's functions in plural, check the <a href="../crypto_primitives.html">crypto primitives section</a> for details on this). This struct provides us with methods to instantiate a merkle tree with 
a given list of leaves:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns a new merkle tree. `leaves.len()` should be power of two.
pub fn new&lt;L: ToBytes&gt;(
    leaf_hash_param: &amp;LeafParam&lt;P&gt;,
    two_to_one_hash_param: &amp;TwoToOneParam&lt;P&gt;,
    leaves: &amp;[L],
) -&gt; Result&lt;Self, crate::Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>and to generate a merkle path for a given leaf:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns the authentication path from leaf at `index` to root.
pub fn generate_proof(&amp;self, index: usize) -&gt; Result&lt;Path&lt;P&gt;, crate::Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>For our example, this is enough. So far we have a regular merkle tree Rust struct, but what we're looking for is an arkworks circuit to generate and verify ZK proofs of inclusion for this tree. What we'll do is create a second struct to represent this circuit:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct MerkleTreeVerification {
    // These are constants that will be embedded into the circuit
    pub leaf_crh_params: &lt;LeafHash as CRH&gt;::Parameters,
    pub two_to_one_crh_params: &lt;TwoToOneHash as TwoToOneCRH&gt;::Parameters,

    // These are the public inputs to the circuit.
    pub root: Root,
    pub leaf: u8,

    // This is the private witness to the circuit.
    pub authentication_path: Option&lt;SimplePath&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Don't worry too much about the <code>leaf_crh_params</code> and <code>two_to_one_crh_params</code>, they're just variables related to the hash functions being used.</p>
<p>If we recall the <a href="../overview.html#simple-circuit">overview</a>, to turn this struct into a circuit all we have to do is implement the <code>generate_constraints</code> method for the <code>ConstraintSynthetizer</code> trait. This pattern is a very common one throughout arkworks and it's the same one we used in the overview example, the idea is that the fields of our circuit struct are its constant, public and private inputs exposed as regular rust types.</p>
<p>In turn, each of these types has a corresponding <code>R1CS</code> equivalent, which allows creating constant, public or private inputs inside a circuit out of these regular rust types. The simplest example of this is the <code>UInt8</code> gadget we've already covered; it lets you define unsigned 8 bit integers inside a circuit, which is exactly what we need for our leaf public input.</p>
<p>The idea behind this pattern is to give an API to users that entirely abstracts them from the circuit logic. By providing a <code>MerkleTreeVerification</code> struct with regular types as fields, users of the circuit don't need to know what gadgets or constraints are.</p>
<p>All that being said, our <code>generate_constraints</code> method looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_constraints(
        self,
        cs: ConstraintSystemRef&lt;ConstraintF&gt;,
    ) -&gt; Result&lt;(), SynthesisError&gt; {
        // First, we allocate the public inputs
        let root = RootVar::new_input(ark_relations::ns!(cs, &quot;root_var&quot;), || Ok(&amp;self.root))?;
        let leaf = UInt8::new_input(ark_relations::ns!(cs, &quot;leaf_var&quot;), || Ok(&amp;self.leaf))?;

        // Then, we allocate the public parameters as constants:
        let leaf_crh_params = LeafHashParamsVar::new_constant(cs.clone(), &amp;self.leaf_crh_params)?;
        let two_to_one_crh_params =
            TwoToOneHashParamsVar::new_constant(cs.clone(), &amp;self.two_to_one_crh_params)?;

        // Finally, we allocate our path as a private witness variable:
        let path = SimplePathVar::new_witness(ark_relations::ns!(cs, &quot;path_var&quot;), || {
            Ok(self.authentication_path.as_ref().unwrap())
        })?;

        let leaf_bytes = vec![leaf; 1];

        let is_member = path.verify_membership(
            &amp;leaf_crh_params,
            &amp;two_to_one_crh_params,
            &amp;root,
            &amp;leaf_bytes.as_slice(),
        )?;

        is_member.enforce_equal(&amp;Boolean::TRUE)?;

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<p>First we allocate a <code>RootVar</code> public input, which is the <code>R1CS</code> equivalent of a merkle root. This is a type provided by arkworks, which underneath implements the <code>AllocVar</code> trait discussed above. As a general rule, if a type ends with <code>Var</code>, then it's most likely the <code>R1CS</code> equivalent of a regular type. The value for our <code>RootVar</code> public input is <code>&amp;self.root</code>, i.e., the <code>root</code> field value of our <code>MerkleTreeVerification</code> struct.</p>
<p>Next we allocate a <code>UInt8</code> public input representing our leaf and the constant values for <code>leaf_crh_params</code> and <code>two_to_one_crh_params</code>. Again, we're not going to go into much detail about these two parameters, but they're provided by arkworks and are the <code>R1CS</code> equivalent of the parameters required by our merkle tree hash functions (see <a href="../crypto_primitives.html#pedersen-commitment">crypto primitives</a> for more details).</p>
<p>Finally, we have to allocate our private input representing the merkle path, of type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SimplePathVar = PathVar&lt;crate::MerkleConfig, LeafHashGadget, TwoToOneHashGadget, ConstraintF&gt;
<span class="boring">}
</span></code></pre></pre>
<p>This is a gadget provided by arkworks, the <code>R1CS</code> equivalent of <code>Path&lt;P: Config&gt;</code>, it's a bit more complex than the other gadgets we've seen so far and it's at the crux of this entire circuit, so let's dive more into it.</p>
<p>As the <code>R1CS</code> equivalent of <code>Path</code>, <code>PathVar</code> consists of the following fields</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PathVar&lt;P, LeafH, TwoToOneH, ConstraintF&gt;
{
    /// `path[i]` is 0 (false) iff ith non-leaf node from top to bottom is left.
    path: Vec&lt;Boolean&lt;ConstraintF&gt;&gt;,
    /// `auth_path[i]` is the entry of sibling of ith non-leaf node from top to bottom.
    auth_path: Vec&lt;TwoToOneH::OutputVar&gt;,
    /// The sibling of leaf.
    leaf_sibling: LeafH::OutputVar,
    /// Is this leaf the right child?
    leaf_is_right_child: Boolean&lt;ConstraintF&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>(I'm ommiting the generic type definitions to reduce visual clutter). This struct implements the <code>AllocVar</code> trait to be able to create public, private or constant variables by implementing the <code>new_variable</code> method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new_variable&lt;T: Borrow&lt;Path&lt;P&gt;&gt;&gt;(
        cs: impl Into&lt;Namespace&lt;ConstraintF&gt;&gt;,
        f: impl FnOnce() -&gt; Result&lt;T, SynthesisError&gt;,
        mode: AllocationMode,
    ) -&gt; Result&lt;Self, SynthesisError&gt; {
        let ns = cs.into();
        let cs = ns.cs();
        f().and_then(|val| {
            let leaf_sibling = LeafH::OutputVar::new_variable(
                ark_relations::ns!(cs, &quot;leaf_sibling&quot;),
                || Ok(val.borrow().leaf_sibling_hash.clone()),
                mode,
            )?;
            let leaf_position_bit = Boolean::new_variable(
                ark_relations::ns!(cs, &quot;leaf_position_bit&quot;),
                || Ok(val.borrow().leaf_index &amp; 1 == 1),
                mode,
            )?;
            let pos_list: Vec&lt;_&gt; = val.borrow().position_list().collect();
            let path = Vec::new_variable(
                ark_relations::ns!(cs, &quot;path_bits&quot;),
                || Ok(&amp;pos_list[..(pos_list.len() - 1)]),
                mode,
            )?;

            let auth_path = Vec::new_variable(
                ark_relations::ns!(cs, &quot;auth_path_nodes&quot;),
                || Ok(&amp;val.borrow().auth_path[..]),
                mode,
            )?;
            Ok(PathVar {
                path,
                auth_path,
                leaf_sibling,
                leaf_is_right_child: leaf_position_bit,
            })
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>When we called</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SimplePathVar::new_witness(ark_relations::ns!(cs, &quot;path_var&quot;), || {
    Ok(self.authentication_path.as_ref().unwrap())
})?;
<span class="boring">}
</span></code></pre></pre>
<p>passing our <code>authentication_path</code> struct (i.e., our non-R1CS merkle path) in our circuit definition above, this internally called the <code>new_variable</code> method, which instantiates its internal fields by using the appropriate fields in our <code>authentication_path</code>.</p>
<p>After creating a merkle path variable in our circuit, we call its <code>verify_membership</code> method to check that the path is correct</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_member = path.verify_membership(
    &amp;leaf_crh_params,
    &amp;two_to_one_crh_params,
    &amp;root,
    &amp;leaf_bytes.as_slice(),
)?;
<span class="boring">}
</span></code></pre></pre>
<p>this returns an <code>R1CS</code> <code>Boolean</code>, so we can then add a constraint to make sure it is true:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>is_member.enforce_equal(&amp;Boolean::TRUE)?;
<span class="boring">}
</span></code></pre></pre>
<p>Notice that the bulk of our <code>MerkleTree</code> circuit was just this gadget, which provides the <code>R1CS</code> API to use inside a circuit for checking merkle paths. Because it's a gadget, however, we can use it inside other circuits as part of more complex logic. For example, we could combine it with a gadget that verifies <code>Schnorr</code> signatures to create a circuit that takes a signed transaction updating some state in a merkle tree and checks both things: that the signature is valid and that the caller knew a leaf of the tree.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../gadgets/gadgets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../crypto_primitives.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../gadgets/gadgets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../crypto_primitives.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
